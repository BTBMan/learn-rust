fn main() {
    // 变量与常量
    // let a = 1;
    // a = 2; // error

    // let mut a = 1;
    // a = '2'; // error

    // const MY_CONST: u32 = 1; // 必须声明类型

    // 变量覆盖域作用域
    // let x = 1;

    // println!("{}", x);

    // let x = 2; // 覆盖第一个变量

    // println!("{}", x);

    // {
    //     let x = 3;

    //     println!("{}", x) // 查找当前内部作用域x
    // }

    // println!("{}", x); // 访问不到内部作用域

    // 更多数据类型
    // 两类类型字集 (量标scalar 复合compound)
    // 量标 (整型 浮点型 布尔型 字符型) =============================
    // 整型分为 8,16,32,64,128,arch位, i代表有符号即可以是负数 u代表无符号即正数
    // 浮点型分为f23,f64, f32表示单精度浮点数, f64标识双精度浮点数
    // 布尔型分为true和false
    // 字符型char

    // 数值运算
    // println!("{}", 1 + 1);
    // println!("{}", 1.1 + 1.1);
    // println!("{}", 2 / 3); // 整数除法向下舍入最接近的整数

    // 字符型
    // let c = '1';
    // let z: char = '2'; // 显示声明类型
    // println!("{c}----{z}");

    // 复合型 (元祖, 数组) =============================
    // 元祖长度固定, 多个类型的复合类型, 一但声明不能修改, 使用圆括号创建
    // 数组中每个元素的类型是固定的,长度也是固定的

    // let tup: (char, i32) = ('a', 2);
    // let (x, y) = tup; // 可以使用解构
    // println!("{x}----{y}");
    // println!("{}----{}", tup.0, tup.1); // 也可以使用.加索引的方式取值

    // let a = [1, 2, 3];
    // let b: [u32; 2] = [1, 2]; // 显示的声明类型和长度
    // let c = [4; 4]; // 可以给定初始值加;长度来指定这个数组是定义的长度的相同的值
    //                 // 用索引取值
    // println!("{}", a[0]);
    // println!("{}", b[0]);
    // println!("{}", c[0]);

    // 函数
    // fn another_function(x: i32) {
    //     println!("x is {x}")
    // }

    // another_function(12)

    // 块表达式
    // let a = {
    //     let b = 1;
    //     b + 1 // 注意不要写分号, 没有分号是表达式, 有返回值, 有分号则是语句, 不会有返回值.
    // };
    // println!("a is {a}");

    // 函数的返回值
    // fn num(x: i32) -> i32 {
    //     5 + x // 直接指定值(结尾不可以带分号)
    // }
    // fn num(x: i32) -> i32 {
    //     return 5 + x; // 使用return关键字(结尾有分号)
    // }

    // let x = num(1);

    // println!("x is {x}")
}
