# Rust Training

## rustc, rustup, cargo

rustc 类比 node

rustup 类比 nvm

cargo 类比 npm

## 所有权

可以让 rust 无需垃圾回收即可报障内存安全, 相关功能包括借用(borrowing) slice 等.

它在程序的编译时根据一系列的规则进行检查, 如果违反了任何这些规则, 程序都不会编译成功.

### 栈(stack) 与 堆(heap)

#### 栈

后进先出, 顺序存储, 所有数据都必须占用已知且固定的大小. (不认为是分配).

分配内存比堆要快. 访问数据也比堆要快.

当调用函数时, 传递给函数的值和函数的局部变量会被压入栈中, 当函数结束时, 这些值会被移出栈.

#### 堆

缺乏组织, 须要请求一定大小的空间 -> 找到足够大的空间 -> 标记为已使用 -> 返回一个表示改地址的 **指针** (简称分配).

堆中数据的指针是已知的并且大小是固定的, 可以将指针存储了栈中, 当须要实际的数据时, 须要访问指针.

### 规则

1. 每一个值都有一个所有者.
2. 值在任何时刻都只有一个所有者.
3. 当所有者离开作用域, 这个值将被丢弃.

rust 永远不会做数据的深拷贝, 如需深度复制, 则使用类型的 clone 方法.

rust 有 copy trait 的特殊注解, 可以用在存储在栈上的类型, rust 不允许自身或者其任何部分实现了 drop trait 的类型使用 copy trait, 当元祖包涵的类型也都实现了 copy trait 的时候,这个元祖也可以实现 copy trait,如果其他有实现 copy trait 的时候,比如 String,那这个元祖也没有 copy trait.

### 引用与借用

引用(&) **像** 指针, 它是一个地址, 可以访问存储于该地址属于的变量数据. (引用确保指向某个特定类型的有效值, 不具备所有权, 不可修改引用的数据), 这种行为叫作借用.

与之对应的是解引用(\*).

可变引用在&后加 mut 关键字, 可变引用不能对同一个变量创建多个.(可以通过不同作用域来解决这个问题)(也不可以在拥有可以引用的同时拥有可变引用, 当然如果最后一次使用在可变引用之前, 是没有问题的).

#### 悬垂引用

释放内存时保留指针会形成错误的悬垂指针.
